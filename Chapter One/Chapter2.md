## فصل ۲ - تفکر معماری

یک معمار به مسائل نگاه متفاوتی نسبت به یک توسعه‌دهنده دارد؛ درست مانند این که یک هواشناس ابرها را طور دیگری ببیند نسبت به یک نقاش. به این دیدگاه، **تفکر معماری** (Architectural Thinking) گفته می‌شود.

متأسفانه بسیاری از معماران تصور می‌کنند تفکر معماری یعنی صرفاً «فکر کردن به معماری»؛ در حالی که این تنها یک برداشت ساده‌انگارانه است.

تفکر معماری یعنی دیدن مسائل با **چشم یک معمار** و داشتن دیدگاه معماری. این نوع نگاه چهار جنبه اصلی دارد:

1. درک تفاوت میان **معماری** و **طراحی** و دانستن اینکه چگونه باید با تیم‌های توسعه برای عملی کردن معماری همکاری کرد.
2. داشتن گستره وسیعی از دانش فنی (technical breadth) و در عین حال حفظ عمق مشخصی از تخصص (technical depth) تا بتوان راه‌حل‌ها و احتمالاتی را دید که دیگران متوجهشان نمی‌شوند.
3. توانایی درک، تحلیل و موازنه بین **trade-off**‌های مختلف در راهکارها و فناوری‌های گوناگون.
4. شناخت اهمیت عوامل و محرک‌های تجاری (business drivers) و توانایی ترجمه آن‌ها به دغدغه‌ها و تصمیمات معماری.

در این فصل، این چهار جنبه تفکر معماری را بررسی می‌کنیم و می‌بینیم چگونه باید با «چشم معماری» به مسائل نگاه کرد.

------

## معماری در مقابل طراحی

تفاوت بین معماری و طراحی همیشه ساده و واضح نیست. اینکه معماری کجا تمام می‌شود و طراحی از کجا شروع می‌شود، یا مسئولیت‌های یک معمار در برابر مسئولیت‌های یک توسعه‌دهنده دقیقاً چیست، سؤال‌هایی هستند که اغلب پیش می‌آیند.
 تفکر معماری یعنی دانستن این تفاوت‌ها و دیدن اینکه چطور این دو به هم نزدیک و یکپارچه می‌شوند تا هم مشکلات فنی و هم نیازهای تجاری را حل کنند.

بر اساس دیدگاه سنتی، وظایف معمار شامل مواردی به این شکل است:

- تحلیل نیازمندی‌های تجاری و استخراج و تعریف ویژگی‌های معماری («-ilities» مانند scalability، reliability و غیره)
- انتخاب الگوها و سبک‌های معماری متناسب با حوزه مسئله
- ایجاد اجزا و بلوک‌های سازنده سیستم (components)

خروجی یا دستاورد این کارها، سپس به تیم توسعه تحویل داده می‌شود تا آن‌ها وظایف خود را انجام دهند، شامل:

- طراحی دقیق کلاس‌ها برای هر component
- طراحی صفحات رابط کاربری
- توسعه و تست کد منبع

اما این مدل سنتی که در شکل ۲-۲ نشان داده شده، مشکلات زیادی دارد. مشکل اصلی «جهت یک‌طرفه» ارتباط بین معمار و توسعه‌دهندگان است.
 در چنین مدلی:

- تصمیم‌های معمار گاهی هرگز به دست تیم توسعه نمی‌رسند، یا اگر برسند، ناقص منتقل می‌شوند.
- تغییراتی که تیم توسعه در معماری ایجاد می‌کند نیز اغلب به معمار گزارش داده نمی‌شود.

به این ترتیب، معمار از تیم‌های توسعه جدا می‌ماند و معماری به ندرت به آنچه در ابتدا هدف‌گذاری شده بود، دست پیدا می‌کند.

------

## مدل همکاری دوطرفه

برای موفق بودن معماری، باید موانع فیزیکی و ذهنی بین معماران و توسعه‌دهندگان از بین برود و ارتباطی دوطرفه و قوی شکل بگیرد.
 معمار و توسعه‌دهنده باید در یک «تیم مجازی مشترک» قرار گیرند، همان‌طور که در شکل ۲-۳ نشان داده شده است.

این رویکرد مزایایی دارد:

- ایجاد ارتباط مستمر و دوطرفه بین معماری و توسعه
- فراهم‌کردن امکان مربی‌گری و همراهی معمار با اعضای تیم توسعه

برخلاف رویکردهای سنتی و ایستا (مانند waterfall) که معماری در آن‌ها ثابت و بدون تغییر است، معماری سیستم‌های امروز در هر تکرار یا فاز پروژه تغییر و تکامل پیدا می‌کند.
 به همین دلیل، **همکاری نزدیک و مستمر بین معمار و تیم توسعه برای موفقیت هر پروژه نرم‌افزاری ضروری است**.

پاسخ به این سؤال که «معماری کجا تمام می‌شود و طراحی از کجا شروع می‌شود» این است: **هیچ‌جا**؛
 معماری و طراحی بخشی از یک چرخه مداوم زندگی پروژه هستند و باید همواره با هم و در هماهنگی کامل پیش بروند.

## گستره فنی (Technical Breadth)

دامنه جزئیات فنی مورد نیاز برای یک توسعه‌دهنده با آنچه یک معمار نرم‌افزار نیاز دارد متفاوت است.
 برخلاف یک توسعه‌دهنده که برای انجام وظایف خود باید **عمق فنی بالایی** (Technical Depth) داشته باشد، یک معمار نرم‌افزار باید **گستره فنی وسیعی** (Technical Breadth) داشته باشد تا بتواند مانند یک معمار فکر کند و مسائل را از زاویه معماری ببیند.

این موضوع در **هرم دانش** که در شکل ۲-۴ آمده، نشان داده شده است. این هرم تمام دانش فنی موجود در دنیا را در بر می‌گیرد و نکته جالب این است که نوع دانشی که برای یک فرد فنی ارزشمند است، در مراحل مختلف شغلی تغییر می‌کند.

بر اساس شکل ۲-۴، می‌توان همه دانش خود را به سه دسته تقسیم کرد:

1. **چیزهایی که می‌دانید**
2. **چیزهایی که می‌دانید که نمی‌دانید**
3. **چیزهایی که نمی‌دانید که نمی‌دانید**

- **چیزهایی که می‌دانید** شامل فناوری‌ها، فریم‌ورک‌ها، زبان‌ها و ابزارهایی است که هر روز در کار استفاده می‌کنید. برای یک برنامه‌نویس جاوا، دانستن خود زبان جاوا مثالی از این بخش است.
- **چیزهایی که می‌دانید که نمی‌دانید** شامل مواردی است که فقط کمی درباره آن‌ها شنیده‌اید یا شناخت محدودی دارید اما تخصصی در آن ندارید. مثلاً اکثر برنامه‌نویسان از زبان Clojure شنیده‌اند و می‌دانند بر پایه Lisp است، ولی نمی‌توانند در آن کدنویسی کنند.
- **چیزهایی که نمی‌دانید که نمی‌دانید** بزرگ‌ترین بخش هرم است؛ شامل فناوری‌ها و ابزارهایی که شاید بهترین راه‌حل یک مشکل باشند ولی شما حتی از وجودشان خبر ندارید.

در اوایل مسیر شغلی، اولویت توسعه‌دهنده باید **گسترش بخش بالای هرم** باشد، یعنی کسب تجربه و تخصص عملی در فناوری‌های مشخص. این رشد طبیعی باعث می‌شود که بخش میانی هرم نیز گسترش یابد، چون هرچه با فناوری‌های بیشتری آشنا شوید، به فهرست «چیزهایی که می‌دانید که نمی‌دانید» اضافه می‌شود.

همان‌طور که در شکل ۲-۵ نشان داده شده، بزرگ‌تر کردن بخش بالای هرم در این مرحله سودمند است، زیرا تخصص ارزشمند است. ولی باید توجه داشت که **دانسته‌های شما باید حفظ شوند**، زیرا هیچ چیز در دنیای نرم‌افزار ثابت نمی‌ماند. مثلاً اگر در Ruby on Rails متخصص باشید ولی دو سال با آن کار نکنید، آن تخصص از بین می‌رود.
 در واقع، اندازه بخش بالای هرم هر فرد، همان **عمق فنی** اوست.

اما وقتی توسعه‌دهنده وارد نقش معمار می‌شود، ماهیت دانش مورد نیاز تغییر می‌کند. بخش زیادی از ارزش یک معمار، در **شناخت گسترده فناوری‌ها و اینکه چگونه از آن‌ها برای حل مشکلات استفاده کند** است.
 برای مثال، برای یک معمار ارزشمندتر است که بداند ۵ راه‌حل مختلف برای یک مشکل وجود دارد تا اینکه فقط در یکی از آن‌ها متخصص باشد.

مهم‌ترین بخش‌های هرم برای یک معمار، هم بخش بالا و هم بخش میانی است. هرچقدر این بخش میانی به بخش پایینی نفوذ کند، نشان‌دهنده **گستره فنی** اوست (شکل ۲-۶).

برای معمار، **گستره** از **عمق** مهم‌تر است. چون معمار باید بتواند بین محدودیت‌های فنی و قابلیت‌های موجود، بهترین تصمیم را بگیرد؛ داشتن شناخت وسیع از راهکارهای مختلف مزیت بزرگی است. بنابراین، تصمیم هوشمندانه برای یک معمار این است که بخشی از تخصص عمیق خود را فدا کند و زمانش را صرف گسترش دامنه دانش خود در فناوری‌های متنوع کند (شکل ۲-۷).
 البته برخی حوزه‌های تخصصی مورد علاقه حفظ خواهند شد، اما در سایر زمینه‌ها، کاهش عمق و افزایش گستره منطقی‌تر است.

این هرم دانش نشان می‌دهد نقش معمار چه تفاوت بنیادینی با نقش توسعه‌دهنده دارد. توسعه‌دهندگان سال‌ها برای عمیق‌تر کردن دانش خود تلاش می‌کنند، اما ورود به جایگاه معمار نیازمند تغییر این دیدگاه است. این تغییر برای بسیاری سخت است و معمولاً منجر به دو مشکل رایج می‌شود:

1. تلاش برای حفظ تخصص در حوزه‌های بسیار زیاد که باعث خستگی و بی‌نتیجه ماندن همه آن‌ها می‌شود.
2. **تخصص منجمد (Stale Expertise)**؛ یعنی فرد احساس می‌کند اطلاعاتش cutting edge است، در حالی که سال‌ها از به‌روز کردن آن گذشته. این مورد را زیاد در شرکت‌هایی می‌بینیم که بنیان‌گذاران آن‌ها، پس از رسیدن به سمت‌های مدیریتی، همچنان با معیارهای قدیمی تصمیم‌های فنی می‌گیرند (الگوی ضد Frozen Caveman).

معمار باید تمرکز خود را بر **گستره فنی** بگذارد تا ابزارهای بیشتری در «ترکش» تصمیم‌گیری‌هایش داشته باشد. توسعه‌دهندگانی که می‌خواهند وارد نقش معمار شوند، باید نگرششان نسبت به یادگیری را تغییر دهند و همیشه بین **عمق** و **گستره**، تعادلی هوشمندانه برقرار کنند.

## تحلیل مبادله‌ها (Trade-Offs)

تفکر معماری یعنی دیدن **مبادله‌ها** یا همان *trade-off*‌ها در هر راهکار (چه فنی و چه غیر فنی) و تحلیل آن‌ها برای مشخص کردن بهترین انتخاب.
 به قول مارک (یکی از نویسندگان کتاب):

> معماری همان چیزهایی است که نمی‌توانی در گوگل پیدا کنی.

در معماری، همه‌چیز یک trade-off است. به همین دلیل است که پاسخ مشهور به تقریباً هر سؤال معماری این است: «بستگی دارد».
 هرچند شنیدن این جواب ممکن است آزاردهنده باشد، اما حقیقت دارد. شما نمی‌توانید پاسخ قطعی برای اینکه «REST بهتر است یا پیام‌رسانی» یا «مایکروسرویس‌ها بهترین سبک برای این پروژه هستند یا نه» را جستجو کنید، چون واقعاً بستگی دارد — بستگی به محیط استقرار، اهداف تجاری، فرهنگ سازمان، بودجه، زمان‌بندی، مهارت تیم توسعه و ده‌ها عامل دیگر.

به قول نیل (دیگر نویسنده کتاب):

> در معماری، جواب درست یا غلط وجود ندارد — فقط مبادله‌ها وجود دارند.

------

### مثال: سیستم مزایده آنلاین

فرض کنید یک سیستم مزایده دارید که وقتی کاربر یک قیمت پیشنهاد می‌دهد (bid)، سرویس `Bid Producer` آن را گرفته و به سرویس‌های `Bid Capture`، `Bid Tracking` و `Bid Analytics` ارسال می‌کند.

این انتقال داده می‌تواند به یکی از دو روش انجام شود:

1. **با استفاده از topic** در مدل انتشار/اشتراک (Publish-Subscribe) — شکل ۲-۹
2. **با استفاده از queue** در مدل نقطه‌به‌نقطه (Point-to-Point) — شکل ۲-۱۰

------

### مزایای استفاده از Topic

مزیت اصلی رویکرد topic، **قابلیت توسعه معماری (Architectural Extensibility)** است.
 در این روش، `Bid Producer` فقط یک اتصال به topic برقرار می‌کند. اگر بعداً یک سرویس جدید مثل `Bid History` اضافه شود، کافی است به همان topic مشترک شود و نیازی به تغییر در سرویس‌های موجود نیست.

همچنین، در این مدل، `Bid Producer` هیچ اطلاعی از نحوه استفاده داده یا مصرف‌کنندگان آن ندارد — یعنی **وابستگی کمتر** (Decoupling).

------

### مزایای استفاده از Queue

در روش queue، هر سرویس مصرف‌کننده (مانند `Bid Capture`، `Bid Tracking` و …) یک صف مخصوص به خود دارد. این کار اگرچه توسعه سیستم را سخت‌تر می‌کند (زیرا اضافه کردن سرویس جدید نیازمند ایجاد queue و تغییر در `Bid Producer` است)، اما چند مزیت دارد:

1. **مسائل امنیت داده**: در مدل topic، هر سرویس جدیدی می‌تواند مشترک شود و داده‌ها را ببیند، حتی سرویس‌های غیرمجاز. ولی در صف، داده مستقیماً برای مصرف‌کننده مشخص ارسال می‌شود و اگر سرویس غیرمجاز به آن دسترسی پیدا کند، داده از بین می‌رود و هشدار صادر می‌شود.
2. **قراردادهای داده ناهمگن** (Heterogeneous Contracts): در مدل topic، تمام سرویس‌ها باید یک قرارداد داده یکسان را بپذیرند. اما در مدل queue، هر سرویس می‌تواند یک قرارداد داده مخصوص به خود داشته باشد.
3. **پایش و مقیاس‌پذیری برنامه‌ریزی‌شده**: در صف می‌توان تعداد پیام‌های موجود را پایش کرد و بر اساس حجم آن، مصرف‌کنندگان را به صورت مستقل مقیاس‌بندی کرد.

------

## نتیجه‌گیری

در نگاه اول، topic به دلیل انعطاف‌پذیری و توسعه آسان، برنده به نظر می‌رسد.
 اما اگر امنیت، قرارداد داده اختصاصی یا کنترل مقیاس‌بندی نیاز اصلی باشد، queue انتخاب بهتری است.

در معماری، هیچ پاسخ قطعی وجود ندارد و همه‌چیز بستگی به اولویت‌های کسب‌وکار و شرایط پروژه دارد.

------

## درک محرک‌های تجاری (Business Drivers)

بخش مهم تفکر معماری، درک «محرک‌های تجاری» (Business Drivers) است — عواملی که موفقیت سیستم را تعیین می‌کنند — و ترجمه این عوامل به **ویژگی‌های معماری** مثل مقیاس‌پذیری (Scalability)، عملکرد (Performance) و قابلیت دسترسی (Availability).

برای این کار، معمار باید:

- آشنایی نسبی با دامنه کسب‌وکار داشته باشد
- ارتباط خوب و همکاری مؤثر با ذی‌نفعان کلیدی برقرار کند

در فصل ۴ این کتاب، ویژگی‌های مختلف معماری تعریف شده‌اند.
 در فصل ۵، روش‌های شناسایی و ارزیابی آن‌ها بررسی می‌شود.
 و در فصل ۶، نحوه اندازه‌گیری هر ویژگی برای اطمینان از برآورده شدن نیازهای تجاری توضیح داده خواهد شد.

## ایجاد تعادل بین معماری و کدنویسی عملی

یکی از چالش‌های مهمی که یک معمار نرم‌افزار با آن روبه‌رو است، **یافتن تعادل بین کدنویسی عملی و انجام وظایف معماری** است. ما معتقدیم که هر معمار باید توانایی کدنویسی داشته باشد و بتواند سطح مشخصی از **عمق فنی** را حفظ کند (به بخش «گستره فنی» مراجعه کنید).
 هرچند این موضوع ظاهراً ساده به نظر می‌رسد، در عمل ممکن است چندان راحت نباشد.

------

## اجتناب از تله گلوگاه (Bottleneck Trap)

یک نکته مهم در تلاش برای برقراری تعادل بین کدنویسی و معماری، اجتناب از گرفتار شدن در **تله گلوگاه** است.
 این وضعیت زمانی رخ می‌دهد که معمار مالکیت بخشی از کد در **مسیر حیاتی پروژه** (معمولاً کدهای زیرساخت و فریم‌ورک) را بر عهده بگیرد و به دلیل محدودیت زمانی‌اش به یک گلوگاه برای تیم تبدیل شود.
 این مشکل پیش می‌آید چون معمار یک توسعه‌دهنده تمام‌وقت نیست و باید بین نقش توسعه‌دهندگی (نوشتن و تست کد) و نقش معماری (طراحی دیاگرام‌، شرکت در جلسات و البته باز هم جلسات) تعادل برقرار کند.

------

## یک روش مؤثر برای جلوگیری از گلوگاه

یک راه‌حل ساده این است که معمار کدنویسی بخش‌های مهم و فریم‌ورک را به دیگر اعضای تیم توسعه بسپارد و خودش روی پیاده‌سازی یک بخش از **منطق تجاری سیستم** که مربوط به چند iteration بعد است کار کند (یک تا سه تکرار آینده).

با این کار سه نتیجه مثبت ایجاد می‌شود:

1. معمار تجربه عملی در نوشتن کد تولیدی کسب می‌کند بدون اینکه باعث کندی تیم شود.
2. مالکیت بخش‌های کلیدی کد به تیم توسعه منتقل می‌شود، که این باعث افزایش دانش و مسئولیت‌پذیری آنها می‌گردد.
3. مهم‌تر از همه، معمار همان نوع کد کسب‌وکار را می‌نویسد که بقیه تیم توسعه می‌نویسند، بنابراین بهتر می‌تواند شرایط، چالش‌ها و حتی محدودیت‌هایی که تیم تجربه می‌کند را درک کند.

------

## اگر معمار نتواند هم‌زمان با تیم توسعه کد بزند

حتی اگر معمار به هر دلیل نتواند هم‌زمان با تیم توسعه روی کدهای اصلی کار کند، باز هم می‌تواند سطحی از **ارتباط مستقیم با کدنویسی** و عمق فنی را حفظ کند. برای این کار چهار روش اصلی وجود دارد (البته ما توصیه می‌کنیم که تمرین کدنویسی در خانه هم انجام شود):

------

## ۱. ساخت نمونه‌های اثبات مفهوم (Proof of Concept - POC)

این کار نه‌تنها باعث می‌شود معمار مجبور به نوشتن کد شود، بلکه در تصمیم‌گیری‌های معماری نیز کمک بزرگی می‌کند، چون جزئیات پیاده‌سازی را نیز در نظر می‌گیرد.
 برای مثال، اگر معمار بین دو راهکار ذخیره‌سازی کش مردد باشد، می‌تواند برای هر کدام یک نمونه عملی بسازد و نتایج را مقایسه کند.
 این کار علاوه بر نشان دادن پیچیدگی و میزان تلاش لازم برای پیاده‌سازی کامل، امکان مقایسه ویژگی‌های معماری مانند **Scalability**، **Performance** و **Fault Tolerance** را فراهم می‌کند.

**نکته مهم:**
 هر وقت ممکن بود، کد POC باید **در حد کیفیت تولیدی (Production Quality)** نوشته شود. به دو دلیل:

1. کدهای POC اغلب به مخزن کد پروژه اضافه می‌شوند و به عنوان مرجع معماری یا نمونه قابل استفاده توسط تیم باقی می‌مانند؛ بنابراین کد بی‌کیفیت می‌تواند نشان‌دهنده اشتباهات یا استاندارد پایین کار معمار باشد.
2. نوشتن کد با کیفیت تولیدی باعث می‌شود معمار به نوشتن کد تمیز و ساخت‌یافته عادت کند و دچار بدعادت‌های برنامه‌نویسی نشود.

------

## ۲. رسیدگی به بدهی‌های فنی و داستان‌های معماری

راه دیگر برای درگیر ماندن با کدنویسی، برداشتن **بخش‌هایی از کار فنی غیرحیاتی** یا **داستان‌های معماری** پروژه است، تا تیم توسعه بتواند روی پیاده‌سازی قابلیت‌های حیاتی تمرکز کند.
 از آنجا که این وظایف معمولاً کم‌اولویت هستند، اگر معمار نتواند در طول یک iteration آن‌ها را کامل کند، معمولاً مشکل بزرگی برای پیشرفت پروژه ایجاد نمی‌شود.

## ادامه روش‌های حفظ کدنویسی عملی برای معمار

روش دیگر برای حفظ ارتباط معمار با کدنویسی در طول یک iteration، کار کردن روی **رفع باگ‌ها** است.
 هرچند این کار شاید چندان جذاب نباشد، اما به معمار کمک می‌کند نقاط ضعف و مشکلات احتمالی را در کدبیس و حتی در طراحی معماری شناسایی کند.

راهکار دیگر، **استفاده از اتوماسیون** است؛ یعنی معمار می‌تواند ابزارها و اسکریپت‌های ساده‌ی خط فرمان یا آنالایزرهایی بنویسد که به تیم توسعه در انجام کارهای روزمره کمک کنند.
 برای این کار باید به دنبال فعالیت‌های تکراری تیم توسعه بود و آن‌ها را خودکار کرد. این کار معمولاً با استقبال زیادی مواجه می‌شود، چون زمان تیم را آزاد و روند کار را سریع‌تر می‌کند.

مثال‌هایی از این نوع اتوماسیون:

- اعتبارسنج‌های خودکار کد منبع برای بررسی استانداردهای خاصی که ابزارهای lint معمول آن را پوشش نمی‌دهند
- چک‌لیست‌های خودکار
- اسکریپت‌هایی برای انجام ریفکتورهای تکراری و دستی

اتوماسیون می‌تواند در حوزه تحلیل معماری و **Fitness Functions** نیز به کار رود تا از سلامت و انطباق معماری اطمینان حاصل شود. برای مثال، یک معمار می‌تواند با استفاده از کتابخانه [ArchUnit](https://www.archunit.org/) در جاوا، تست‌های خودکاری برای بررسی پایبندی کد به قوانین معماری بنویسد. یا می‌تواند **Fitness Function**‌های اختصاصی بنویسد تا در طول زمان، انطباق معماری را ارزیابی کند و در عین حال تجربه عملی کسب نماید. این مباحث در فصل ۶ به تفصیل بررسی خواهند شد.

در نهایت، یک روش مؤثر دیگر، **انجام بازبینی کد (Code Review)** است. هرچند معمار در این روش خودش کد نمی‌نویسد، اما درگیر کد می‌ماند، از نزدیک استانداردها را بررسی می‌کند، از انطباق کد با معماری مطمئن می‌شود و حتی فرصت‌های مربی‌گری و راهنمایی تیم را پیدا می‌کند.

------

# فصل ۳ - ماژولار بودن (Modularity)

قبل از هر چیز لازم است برخی اصطلاحات رایج (و حتی بیش از حد استفاده شده) در بحث معماری درباره ماژولار بودن را بازبینی و برای کاربرد در این کتاب تعریف کنیم.

> ۹۵٪ بحث‌ها درباره معماری نرم‌افزار روی مزایای «ماژولار بودن» تمرکز می‌کنند، اما درباره نحوه دستیابی به آن تقریباً چیزی گفته نمی‌شود.
>  — گلن‌فورد جِی. مایرز (۱۹۷۸)

پلتفرم‌های مختلف راهکارهای متفاوتی برای **استفاده مجدد (Reuse)** از کد ارائه می‌کنند، اما همگی به نوعی از *ماژول* برای گروه‌بندی کدهای مرتبط استفاده می‌کنند.
 این مفهوم جهانی است، اما تعریف دقیقی که در همه جا پذیرفته شده باشد وجود ندارد. در یک جستجوی ساده اینترنتی ده‌ها تعریف مختلف (و گاهی متناقض) پیدا می‌شود. همان‌طور که مایرز در نقل‌قول بالا اشاره می‌کند، این مشکل جدیدی نیست.

با توجه به نبود تعریف واحد، ما ناچاریم تعریف خودمان را ارائه کنیم تا در طول کتاب یک زبان مشترک داشته باشیم.

درک «ماژولار بودن» و پیاده‌سازی آن در زبان و پلتفرم انتخابی، برای یک معمار حیاتی است. بسیاری از ابزارهای تحلیل معماری (مانند معیارها، fitness function‌ها و ابزارهای مصورسازی) بر پایه این مفاهیم عمل می‌کنند.

ماژولار بودن در معماری یک اصل سازمان‌دهنده است. اگر معمار به نحوه اتصال قطعات سیستم توجه نکند، خروجی سیستمی خواهد بود پر از مشکل و پیچیدگی.
 همان‌طور که در فیزیک، سیستم‌های پیچیده به سمت بی‌نظمی (Entropy) می‌روند و برای حفظ نظم باید انرژی صرف شود، در سیستم‌های نرم‌افزاری نیز باید دائماً انرژی اختصاص داد تا ساختار سیستم سالم و منظم باقی بماند.

حفظ ماژولار بودن را می‌توان نوعی «ویژگی ضمنی» معماری دانست، زیرا معمولاً در نیازمندی‌های پروژه نوشته نمی‌شود که معماری باید تمایز و ارتباطات ماژولار خوبی داشته باشد، با این حال هر کد قابل نگهداری و پایداری به آن نیاز دارد.

------

## تعریف

در لغت، **ماژول** یعنی «هر یک از واحدهای استاندارد یا قطعات مستقل که می‌توانند برای ساخت یک ساختار پیچیده‌تر به کار روند».
 ما در این کتاب **ماژولار بودن** را به معنای گروه‌بندی منطقی کدهای مرتبط به کار می‌بریم — این گروه‌بندی می‌تواند مجموعه‌ای از کلاس‌ها در زبان شیء‌گرا یا مجموعه‌ای از توابع در زبان‌های ساختاری یا تابعی باشد.

بسیاری از زبان‌ها مکانیزم‌هایی برای ماژولار بودن فراهم می‌کنند (مثل `package` در جاوا یا `namespace` در .NET).
 مثلاً در جاوا، پکیج `com.mycompany.customer` باید حاوی تمام بخش‌های مرتبط به مشتری باشد.

امروزه زبان‌ها طیف وسیعی از مکانیزم‌های بسته‌بندی دارند و انتخاب بین آن‌ها برای توسعه‌دهنده ساده نیست.
 در بعضی زبان‌ها، کد می‌تواند در توابع/متدها، کلاس‌ها یا پکیج‌ها/namespace‌ها سازمان‌دهی شود، با قوانین متفاوتی برای محدوده (scope) و قابلیت دید (visibility). بعضی زبان‌ها حتی امکانات پیشرفته‌ای مثل **Metaobject Protocol** دارند که ابزارهای توسعه را گسترده‌تر می‌کند.

معمار باید بداند که توسعه‌دهندگان چگونه اجزا را بسته‌بندی می‌کنند چون این موضوع تاثیر مستقیم بر معماری دارد. مثلاً اگر چند پکیج به هم وابستگی شدید داشته باشند، استفاده مجدد از یکی از آن‌ها مشکل خواهد شد.

در این کتاب وقتی از «ماژولار بودن» صحبت می‌کنیم، منظور یک گروه‌بندی مرتبط از کد است — چه کلاس باشد، چه تابع یا هر چیز دیگر — و این الزاماً به معنی جدایی فیزیکی نیست، بلکه جدایی منطقی است. این تفاوت گاهی مهم است.
 برای مثال، ممکن است تعداد زیادی کلاس در یک اپلیکیشن مونولیت کنار هم قرار گیرند، که در ابتدا راحت به نظر برسد، اما وقتی بخواهید ساختار معماری را تغییر دهید، این وابستگی بالا مانع جداسازی مؤثر بخش‌ها می‌شود.

------

## اندازه‌گیری ماژولار بودن

با توجه به اهمیت ماژولار بودن، معمارها به ابزارهایی برای اندازه‌گیری آن نیاز دارند. خوشبختانه معیارهای مستقل از زبان برنامه‌نویسی وجود دارند که به درک ماژولار بودن کمک می‌کنند. ما روی سه مفهوم کلیدی تمرکز می‌کنیم:

- **انسجام (Cohesion)**
- **کوپلینگ (Coupling)**
- **Connascence**

------

### انسجام (Cohesion)

انسجام به این اشاره دارد که اجزای یک ماژول تا چه حد باید در همان ماژول قرار بگیرند.
 به زبان ساده، اندازه‌گیری میزان مرتبط بودن اجزای یک ماژول با یکدیگر است.

یک ماژول منسجم، شامل تمام اجزای ضروری برای عملکرد آن است و تقسیم آن به ماژول‌های کوچک‌تر باعث افزایش وابستگی و کاهش خوانایی می‌شود.

به گفته لری کانستنتین:

> تلاش برای تقسیم یک ماژول منسجم، تنها باعث افزایش وابستگی و کاهش خوانایی خواهد شد.

------

انواع انسجام (از قوی‌ترین تا ضعیف‌ترین):

1. **انسجام عملکردی (Functional Cohesion)** – همه اجزای ماژول به هدف یکسانی خدمت می‌کنند و برای عملکرد آن ضروری‌اند.

2. **انسجام ترتیبی (Sequential Cohesion)** – خروجی یک ماژول ورودی ماژول دیگر است.

3. **انسجام ارتباطی (Communicational Cohesion)** – ماژول‌ها با تبادل یا پردازش داده‌های مشابه به یک خروجی مشترک کمک می‌کنند.

4. **انسجام رویه‌ای (Procedural Cohesion)** – ماژول‌ها باید در یک ترتیب مشخص اجرا شوند.

5. **انسجام زمانی (Temporal Cohesion)** – ماژول‌ها به دلیل وابستگی زمانی گروه‌بندی شده‌اند (مثل کارهای متنوعی که باید در راه‌اندازی سیستم انجام شوند).

6. **انسجام منطقی (Logical Cohesion)** – داده‌ها از نظر منطقی مرتبط هستند، نه عملکردی (مثل ماژول‌های `StringUtils` در جاوا).

7. **انسجام تصادفی (Coincidental Cohesion)** – عناصر فقط به‌طور تصادفی در یک فایل کنار هم قرار گرفته‌اند و ارتباط مفهومی ندارند (ضعیف‌ترین نوع).

    وجود اینکه هفت نوع مختلف برای **انسجام** (Cohesion) تعریف شده، انسجام همچنان یک معیار دقیق به اندازه‌ی **کوپلینگ** (Coupling) نیست.
    در بسیاری از موارد، میزان انسجام یک ماژول به **قضاوت و تشخیص معمار نرم‌افزار** بستگی دارد.

   ------

   ## یک مثال

   فرض کنید ماژولی با نام `Customer Maintenance` داریم که شامل عملیات زیر است:

   - `add customer` (افزودن مشتری)
   - `update customer` (به‌روزرسانی مشتری)
   - `get customer` (دریافت اطلاعات مشتری)
   - `notify customer` (اطلاع‌رسانی به مشتری)
   - `get customer orders` (دریافت سفارش‌های مشتری)
   - `cancel customer orders` (لغو سفارش‌های مشتری)

   سؤال این است که آیا دو مورد آخر باید در همین ماژول باقی بمانند، یا بهتر است به یک ماژول جداگانه منتقل شوند، مثلاً:

   **ماژول Customer Maintenance**

   - add customer
   - update customer
   - get customer
   - notify customer

   **ماژول Order Maintenance**

   - get customer orders
   - cancel customer orders

   ------

   ## کدام ساختار درست است؟

   مثل همیشه، **به شرایط بستگی دارد**:

   - آیا این دو عملیات تنها وظایف `Order Maintenance` هستند؟ اگر بله، شاید منطقی باشد که دوباره آن‌ها را در `Customer Maintenance` ادغام کنید.
   - آیا پیش‌بینی می‌شود که ماژول `Customer Maintenance` در آینده خیلی بزرگ‌تر شود؟ اگر چنین است، شاید بهتر باشد برای ساده‌سازی نگهداری، رفتارها را جدا کنید.
   - آیا `Order Maintenance` برای انجام کارهایش به حدی به اطلاعات مشتری نیاز دارد که جدا کردن آن باعث ایجاد **وابستگی بالا (Coupling)** شود؟ اگر بله، طبق گفته لری کانستنتین، جدا کردن آن می‌تواند مشکل‌ساز شود.

   این پرسش‌ها نمونه‌ای از **تحلیل‌های trade-off** هستند که در قلب کار یک معمار نرم‌افزار قرار دارند.

   ------

   ## یک معیار ساختاری برای اندازه‌گیری انسجام

   با وجود ماهیت ذهنی انسجام، دانشمندان علوم کامپیوتر یک معیار ساختاری مفید برای اندازه‌گیری آن (یا به طور دقیق‌تر، **کمبود انسجام**) معرفی کرده‌اند.

   **مجموعه معیارهای شیء‌گرای Chidamber و Kemerer** یکی از شناخته‌شده‌ترین آن‌هاست که برای سنجش جنبه‌های مختلف سیستم‌های نرم‌افزاری شیء‌گرا توسعه داده شده است. این مجموعه شامل معیارهای شناخته‌شده‌ای مثل:

   - **پیچیدگی سایکلوماتیک** (Cyclomatic Complexity)
   - و چند معیار مهم در حوزه **کوپلینگ** (که در بخش Coupling بررسی خواهد شد)

   از جمله معیارهای این مجموعه، **LCOM** یا **Lack of Cohesion in Methods** است که انسجام ساختاری یک ماژول (معمولاً یک کامپوننت) را اندازه‌گیری می‌کند.
    نسخه اولیه این معیار در **فرمول 3-1** ارائه شده است.

   افزایش مقدار **P** زمانی اتفاق می‌افتد که یک متد به یک فیلد مشترک مشخص دسترسی **نداشته باشد**، و مقدار **Q** زمانی کاهش می‌یابد که متد به یک فیلد مشترک مشخص **دسترسی داشته باشد**.
    نویسندگان این معیار اذعان دارند که درک این فرمول چندان ساده نیست. بدتر این‌که نسخه این فرمول در گذر زمان پیچیده‌تر هم شده است. نسخه دوم که در سال ۱۹۹۶ معرفی شد (و به همین دلیل **LCOM96B** نام‌گذاری گردید) در معادله ۳-۲ آمده است.

   ما وارد جزئیات متغیرها و عملگرهای این معادله نمی‌شویم، چون توضیح متنی زیر شفاف‌تر است:

   ------

   ### تعریف ساده‌شده‌ی LCOM

   **LCOM**: مجموع مجموعه‌هایی از متدها که از طریق اشتراک در استفاده از فیلدها، مشترک نیستند.

   برای مثال، فرض کنید کلاسی دو فیلد خصوصی `a` و `b` دارد. بسیاری از متدها فقط به `a` دسترسی دارند و بسیاری دیگر فقط به `b`. **مجموع** مجموعه‌های متدهایی که از طریق استفاده از فیلدها با هم اشتراک ندارند زیاد است؛ بنابراین این کلاس یک مقدار **LCOM** بالا خواهد داشت که نشان‌دهنده **کمبود انسجام** میان متدها است.

   ------

   ### مثال تصویری

   در شکل ۳-۱، فیلدها با شکل هشت‌ضلعی و متدها با مربع نمایش داده شده‌اند:

   - در کلاس **X**، مقدار LCOM پایین است، که به معنای انسجام ساختاری خوب است.
   - در کلاس **Y**، انسجام پایینی وجود دارد؛ هر جفت فیلد/متد می‌تواند بدون تغییر رفتار در یک کلاس جداگانه قرار گیرد.
   - در کلاس **Z** انسجام ترکیبی دیده می‌شود، به طوری که توسعه‌دهندگان می‌توانند جفت آخر فیلد/متد را به یک کلاس جدا انتقال دهند.

   ------

   ### کاربرد LCOM برای معماران

   این معیار برای معمارانی که کدبیس را به‌منظور تغییر سبک معماری تحلیل می‌کنند بسیار مفید است. یکی از مشکلات رایج در این فرایند، وجود **کلاس‌های ابزاری (Utility Classes) مشترک** است. استفاده از LCOM می‌تواند به شناسایی کلاس‌هایی کمک کند که به‌طور اتفاقی کوپل شده‌اند و اصولاً نباید در یک کلاس واحد قرار می‌گرفتند.

   البته مثل بسیاری از معیارهای نرم‌افزار، LCOM هم محدودیت دارد. این معیار فقط می‌تواند **کمبود انسجام در ساختار** را پیدا کند و توانایی سنجش اینکه آیا اجزای خاص از نظر **منطقی** به هم مرتبط هستند یا خیر را ندارد. این موضوع ما را دوباره به **قانون دوم معماری نرم‌افزار** می‌رساند: تمرکز بر «چرا» مهم‌تر از «چگونه» است.

   ------

   ## کوپلینگ (Coupling)

   خوشبختانه ابزارهای بهتری برای تحلیل کوپلینگ در کدبیس وجود دارد که بخشی از آن مبتنی بر **نظریه گراف** است؛ چون رفتار فراخوانی متدها و بازگشت‌ها یک **گراف فراخوانی (Call Graph)** ایجاد می‌کند، و این امکان را می‌دهد که با ریاضیات آن را تحلیل کنیم.

   در سال ۱۹۷۹، **ادوارد یوردان** و **لری کانستنتین** در کتاب *Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design* (انتشارات Prentice-Hall)، بسیاری از مفاهیم اصلی از جمله معیارهای **Afferent Coupling** و **Efferent Coupling** را معرفی کردند:

   - **Afferent Coupling**: تعداد اتصال‌های ورودی به یک مؤلفه (Component، کلاس، تابع و غیره).
   - **Efferent Coupling**: تعداد اتصال‌های خروجی از یک مؤلفه به دیگر مؤلفه‌ها.

   برای تقریباً تمام پلتفرم‌ها ابزارهایی وجود دارد که به معماران کمک می‌کند ویژگی‌های کوپلینگ در کد را تحلیل کنند تا فرایندهایی مثل **بازساخت (Refactoring)**، مهاجرت یا درک ساختار سیستم را ساده‌تر سازند.

   ------

   ## انتزاع، ناپایداری و فاصله از توالی اصلی

   هرچند مقدار خام کوپلینگ یک مؤلفه برای معمار ارزشمند است، اما شاخص‌های مشتق‌شده دیگری وجود دارند که ارزیابی عمیق‌تری ارائه می‌دهند. این شاخص‌ها توسط **رابرت مارتین** برای کتابی درباره ++C معرفی شدند، ولی در سایر زبان‌های شیء‌گرا هم قابل استفاده هستند.

   - **انتزاع (Abstractness)**: نسبت اجزای انتزاعی (مثل کلاس‌های Abstract، Interface و …) به اجزای اجرایی واقعی (Concrete).
     این شاخص نشان‌دهنده نسبت «میزان انتزاع» به «میزان پیاده‌سازی» است.

   برای مثال:

   - یک کدبیس بدون هیچ گونه انتزاع — مثل یک تابع `main()` بسیار بزرگ — مقدار Abstractness بسیار پایینی دارد.
   - در مقابل، یک کدبیس بیش‌ازحد انتزاعی، فهمیدن اتصالات و عملکرد اجزا را برای توسعه‌دهندگان سخت می‌کند (مثلاً تشخیص کاربرد یک کلاس پیچیده با نامی مثل `AbstractSingletonProxyFactoryBean`).

   ------

   فرمول محاسبه **انتزاع** در معادله ۳-۳ آمده است.معادله 3-3. انتزاع (Abstractness)

   در این معادله:

   - **ma** نشان‌دهنده عناصر **انتزاعی** (interface‌ها یا کلاس‌های انتزاعی) در یک ماژول است.
   - **mc** نشان‌دهنده عناصر **واقعی یا اجرایی** (کلاس‌های غیرانتزاعی) است.

   به بیان ساده، این معیار نسبت تعداد اجزای انتزاعی به تعداد اجزای اجرایی را اندازه‌گیری می‌کند.

   یک راه ساده برای تصور این معیار: فرض کنید یک نرم‌افزار ۵۰۰۰ خط کد دارد و تمام آن در یک متد `main()` قرار دارد. نسبت انتزاع در این حالت تقریباً صفر خواهد بود، چون تنها یک جزء انتزاعی (مثلاً یک کلاس) داریم و بقیه همه اجزای اجرایی هستند.

   بنابراین، **Abstractness** در واقع نسبت کل اجزای انتزاعی به کل اجزای اجرایی در کد شماست.

   ------

   ### معادله 3-4. ناپایداری (Instability)

   **Instability** نسبت **Coupling خروجی (Efferent)** به مجموع **Coupling خروجی و ورودی** است.

   در این معادله:

   - **ce** = Efferent (ارتباطات خروجی)
   - **ca** = Afferent (ارتباطات ورودی)

   این معیار، میزان آسیب‌پذیری یک کدبیس در برابر تغییرات را نشان می‌دهد. هرچه ناپایداری بیشتر باشد، احتمال شکستن سیستم در اثر تغییرات بالاتر است، چون وابستگی به کدهای خارجی بیشتر است.

   برای مثال، اگر یک کلاس فراخوانی‌های زیادی به کلاس‌های دیگر داشته باشد، هر تغییری در آن کلاس‌های دیگر می‌تواند باعث شکست این کلاس شود.

   ------

   ## فاصله از خط اصلی (Distance from the Main Sequence)

   یکی از معدود معیارهای جامع برای ارزیابی ساختار معماری، **Distance from the Main Sequence** است که بر اساس **Abstractness** و **Instability** محاسبه می‌شود (معادله 3-5).

   در این فرمول:

   - **A** = Abstractness
   - **I** = Instability

   از آنجا که هر دو مقدار بین 0 و 1 قرار می‌گیرند، رسم آن‌ها روی نمودار یک خط ایده‌آل ایجاد می‌کند که به آن **Main Sequence** می‌گوییم (شکل 3-2).

   کلاس‌هایی که نزدیک این خط هستند، تعادل مناسبی بین انتزاع و ناپایداری دارند.

   در شکل 3-3، یک کلاس نمونه روی نمودار ترسیم شده و فاصله‌اش از خط ایده‌آل اندازه‌گیری می‌شود: هرچه این فاصله کمتر باشد، تعادل کلاس بهتر است.

   اگر کلاسی خیلی در ناحیه بالا-راست باشد، وارد **Zone of Uselessness** یا «منطقه بی‌فایدگی» می‌شود — یعنی بیش‌ازحد انتزاعی است و استفاده از آن سخت می‌شود.

   برعکس، اگر کلاسی در ناحیه پایین-چپ باشد، وارد **Zone of Pain** یا «منطقه درد» می‌شود — یعنی پیاده‌سازی زیاد و انتزاع کم دارد، به همین دلیل شکننده و دشوار برای نگهداری است (شکل 3-4).

   در بسیاری از پلتفرم‌ها ابزارهایی وجود دارند که این معیارها را محاسبه می‌کنند و به معمارها در تحلیل کدبیس، مخصوصاً هنگام **مهاجرت معماری** یا ارزیابی **بدهی فنی**، کمک می‌کنند.

   ------

   نکته جالب اینکه کتاب معروف **Structured Design** اثر «ادوارد یوردان» و «لری کانستنتین» قبل از محبوبیت زبان‌های شیءگرا منتشر شده و بیشتر روی برنامه‌نویسی ساخت‌یافته (تابع و روال‌ها) تمرکز داشته است. این کتاب انواع دیگری از کوپلینگ را هم تعریف می‌کند که امروزه جای خود را به مفهومی به نام **Connascence** داده‌اند.

   ------

   ## Connascence

   در سال ۱۹۹۶، **Meilir Page-Jones** کتابی با عنوان *آنچه هر برنامه‌نویس باید درباره طراحی شیءگرا بداند* منتشر کرد و در آن، معیارهای **Afferent** و **Efferent Coupling** را برای زبان‌های شیءگرا بازتعریف و با مفهومی به نام **Connascence** معرفی کرد.

   > دو مؤلفه **Connascent** هستند اگر تغییر در یکی، نیاز داشته باشد دیگری هم تغییر کند تا درستی کلی سیستم حفظ شود.

   او Connascence را به دو نوع اصلی تقسیم کرد: **Static** و **Dynamic**.

   ------

   ### Connascence ایستا (Static Connascence)

   Connascence ایستا به **وابستگی در سطح کد منبع** اشاره دارد (برخلاف وابستگی زمان اجرا که در Connascence پویا بررسی می‌شود).

   این نوع، در واقع شکلی پیشرفته‌تر از همان Afferent و Efferent Coupling است. به بیان ساده، Static Connascence، درجه وابستگی مستقیم بین مؤلفه‌ها را مشخص می‌کند.

   انواع رایج Static Connascence عبارتند از:

   1. **Connascence of Name (CoN)**
       چند مؤلفه باید روی یک **نام مشترک** توافق داشته باشند.
       رایج‌ترین مثال در کدها، وابستگی به نام متدهاست که با ابزارهای Refactoring مدرن به‌سادگی تغییر می‌کنند.

   2. **Connascence of Type (CoT)**
       چند مؤلفه باید روی **نوع داده** یک موجودیت توافق داشته باشند.
       این مورد در زبان‌های ایستای نوع‌دار (Statically Typed) رایج است. البته برخی زبان‌های داینامیک مثل **Clojure** و ابزار **Clojure Spec** هم امکان اعمال انتخابی نوع‌دهی را دارند.

   3. **Connascence of Meaning (CoM)** یا **Connascence of Convention (CoC)**
       چند مؤلفه باید روی **معنای مقادیر خاص** توافق داشته باشند. رایج‌ترین مثال، استفاده از مقادیر ثابت (Constant) به جای اعداد هاردکد نشده است.
       فرض کنید جایی تعریف کنید:

      ```
      c
      ```

      `int TRUE = 1; int FALSE = 0; `

      اگر کسی اشتباهاً این مقادیر را جابه‌جا کند، تمام بخش‌هایی که از این متغیرها استفاده می‌کنند دچار خطا می‌شوند.

      ### Connascence of Position (CoP) – همنام‌زادی موقعیت

      زمانی رخ می‌دهد که چند موجودیت باید بر سر **ترتیب مقادیر** توافق داشته باشند.

      این مشکل حتی در زبان‌هایی که نوع‌دهی ایستا دارند هم دیده می‌شود، معمولاً در بحث **ترتیب پارامترهای متد یا تابع**.
       برای مثال، اگر توسعه‌دهنده متدی تعریف کند:

      ```
      java
      void updateSeat(String name, String seatLocation) 
      ```

      و آن را این‌گونه فراخوانی کند:

      ```
      java
      updateSeat("14D", "Ford, N"); 
      ```

      از نظر نوع داده‌ها مشکلی وجود ندارد، اما از نظر معنا اشتباه است چون جای پارامترها جابه‌جا شده است.

      ------

      ### Connascence of Algorithm (CoA) – همنام‌زادی الگوریتم

      زمانی رخ می‌دهد که چند مؤلفه باید بر سر یک **الگوریتم مشخص** توافق داشته باشند.

      یک نمونه رایج این است که الگوریتم هش (Hashing) امنیتی باید هم روی سرور و هم روی کلاینت اجرا شود و **نتایج دقیقاً یکسانی** بدهد تا احراز هویت انجام گیرد.
       کوچک‌ترین تغییر در هر سمت باعث شکستن کل فرآیند می‌شود. این یعنی یک **شکل قوی از کوپلینگ**.

      ------

      ## Connascence پویا (Dynamic Connascence)

      نوع دوم Connascence که **Page-Jones** معرفی کرد، **Connascence پویا** است که وابستگی را **در زمان اجرا** تحلیل می‌کند.

      انواع Connascence پویا:

      ### Connascence of Execution (CoE) – همنام‌زادی اجرای ترتیبی

      ترتیب اجرای چند مؤلفه اهمیت دارد.

      مثلاً:

      ```
      java
      Email email = new Email(); email.setRecipient("foo@example.com"); email.setSender("me@me.com"); email.send(); email.setSubject("whoops"); // اشتباه: Subject باید قبل از send تنظیم شود 
      ```

      در این مثال برخی ویژگی‌ها باید **قبل از ارسال ایمیل** تنظیم شوند، در غیر این صورت برنامه درست کار نمی‌کند.

      ------

      ### Connascence of Timing (CoT) – همنام‌زادی زمان‌بندی

      زمان اجرای چند مؤلفه مهم است.

      یک مثال رایج، **Race Condition** است که وقتی دو Thread در یک زمان اجرا می‌شوند و اجرای هم‌زمان آن‌ها نتیجه عملیات را تغییر می‌دهد.

      ------

      ### Connascence of Values (CoV) – همنام‌زادی مقادیر

      زمانی رخ می‌دهد که چند مقدار به هم وابسته‌اند و باید **همزمان تغییر کنند**.

      مثلاً یک مستطیل که با چهار نقطه (گوشه‌ها) تعریف شده است — تغییر یک نقطه بدون تغییر نقاط دیگر، شکل هندسی را نامعتبر می‌کند.

      نمونه رایج‌تر در **تراکنش‌ها** (به‌خصوص در سیستم‌های توزیع‌شده) دیده می‌شود؛ وقتی باید یک مقدار را به‌طور یکپارچه در چند دیتابیس به‌روز کرد، همه تغییرات باید با هم انجام شوند یا هیچ‌کدام انجام نشوند.

      ------

      ### Connascence of Identity (CoI) – همنام‌زادی هویت

      وقتی چند مؤلفه باید یک **ساختار داده مشترک** داشته باشند و تغییرات آن را به اشتراک بگذارند.

      یک مثال معمول، دو سرویس مستقل است که باید یک **صف توزیع‌شده** مشترک را به‌روزرسانی کنند.

      ------

      ### دشواری شناسایی Connascence پویا

      شناسایی Connascence پویا برای معمارها سخت‌تر است، چون ابزارهای تحلیل زمان اجرا به اندازه ابزارهای تحلیل **Call Graph** مؤثر نیستند.

      ------

      ## ویژگی‌های Connascence

      Connascence برای تحلیل کد توسط معماران و توسعه‌دهندگان استفاده می‌شود و دارای چند ویژگی مهم است:

      ### Strength (قدرت)

      قدرت Connascence به **میزان سختی یا آسانی ریفکتور آن** توسط توسعه‌دهنده بستگی دارد.
       همه انواع Connascence به یک اندازه بد نیستند؛ بعضی فرم‌ها «دلپذیرتر» و آسان‌تر برای بهبود هستند.

      📌 بهتر است معمار **Connascence ایستا** را به **Connascence پویا** ترجیح دهد چون به‌راحتی با بررسی کد منبع قابل شناسایی است و ابزارهای مدرن تغییر آن را آسان می‌کنند.

      مثال: **Connascence of Meaning** را می‌توان با تعریف **ثابت‌های نام‌گذاری‌شده** به جای مقادیر جادویی (Magic Number) به **Connascence of Name** تبدیل کرد.

      ------

      ### Locality (محلی بودن)

      محلی‌ بودن Connascence نشان می‌دهد که دو بخش کد چقدر به هم نزدیک‌اند.

      - اگر دو کلاس در یک ماژول باشند، وجود Connascence شدید بین آن‌ها کمتر مشکل‌ساز است.
      - اما اگر همان نوع Connascence بین دو ماژول جدا باشد، مشکل بیشتری برای ساختار ایجاد می‌کند.

      ------

      ### Degree (درجه)

      درجه Connascence به میزان گستردگی اثر آن بستگی دارد — آیا فقط چند کلاس را تحت‌تأثیر قرار می‌دهد یا بخش بزرگی از سیستم را؟

      - Connascence قوی ولی محدود به چند ماژول، مشکل زیادی ایجاد نمی‌کند.
      - ولی با رشد کدبیس، همین وابستگی‌های کوچک می‌توانند به مشکلات بزرگ تبدیل شوند.

      ------

      ### سه راهکار Page-Jones برای بهبود ماژولاریته با Connascence

      1. **کاهش Connascence کلی** با شکستن سیستم به واحدهای کپسوله‌شده
      2. **کاهش Connascence باقی‌مانده** که از مرزهای کپسوله عبور می‌کند
      3. **افزایش Connascence داخلی** درون مرزهای کپسوله

      ------

      ### توصیه‌های Jim Weirich

      > **قانون درجه (Rule of Degree):** فرم‌های قوی Connascence را به فرم‌های ضعیف‌تر تبدیل کنید.
      >  **قانون محلی بودن (Rule of Locality):** هرچه فاصله بین اجزای نرم‌افزار بیشتر باشد، از Connascence ضعیف‌تر استفاده کنید.

      ------

      ## یکپارچه‌سازی معیارهای Coupling و Connascence

      Coupling و Connascence هر دو به موضوع **وابستگی** پرداخته و از دو دوره و دیدگاه متفاوت آمده‌اند.

      - **Connascence ایستا** تقریباً معادل همان Coupling ورودی و خروجی (Afferent/Efferent) است.
      - تفاوت این است که Connascence به **چگونگی** اتصال اهمیت می‌دهد، نه فقط به تعداد ارتباطات.

      در شکل 3-6 این هم‌پوشانی نشان داده شده است:

      - در سمت چپ مفاهیم Coupling از دنیای «برنامه‌نویسی ساخت‌یافته» دیده می‌شود.
      - در سمت راست ویژگی‌های Connascence.

      ------

      ## مشکلات Connascence سنتی دهه ۹۰

      1. این معیارها بیشتر روی **جزئیات کد سطح پایین** تمرکز داشتند (برای بهبود کیفیت کد)، نه لزوماً ساختار معماری کلان. ولی معمار بیشتر روی **نوع وابستگی** بین ماژول‌ها تمرکز دارد.
      2. Connascence سنتی به پرسش‌های رایج معماری مدرن، مانند انتخاب **معماری همگام (Synchronous)** یا **ناهمگام (Asynchronous)** در سیستم‌های توزیع‌شده (مثل مایکروسرویس‌ها)، پاسخی نمی‌دهد.

      با یادآوری «قانون اول معماری نرم‌افزار» – همه‌چیز یک trade-off است – در فصل 7 روش‌های جدیدتری برای فکر کردن به Connascence مدرن مطرح خواهیم کرد.

      ------

      ## از ماژول تا کامپوننت

      ما واژه **ماژول** را برای اشاره کلی به هر گروه کد مرتبط به کار بردیم. اما بیشتر پلتفرم‌ها از مفهومی پیشرفته‌تر به نام **کامپوننت** پشتیبانی می‌کنند که یکی از **بلوک‌های اصلی طراحی معماری** است.

      این ایده و تحلیل جداسازی منطقی یا فیزیکی از همان روزهای اولیه علوم کامپیوتر مطرح بوده است، اما هنوز هم برنامه‌نویسان و معماران در رسیدن به **نتایج خوب** در جداسازی بخش‌ها، مشکل دارند.

      در فصل 8 خواهیم دید چگونه می‌توانیم از **دامنه مسئله** (Problem Domain) برای استخراج کامپوننت‌ها استفاده کنیم. اما پیش از آن، باید یکی از مفاهیم بنیادی معماری نرم‌افزار یعنی **ویژگی‌های معماری (Architecture Characteristics)** و **دامنه آن‌ها** را بررسی کنیم.