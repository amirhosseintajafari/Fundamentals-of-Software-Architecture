## فصل ۲. تفکر معماری (_Architectural Thinking_)

یک معمار به مسائل از دیدگاهی متفاوت نسبت به یک توسعه‌دهنده نگاه می‌کند، همان‌طور که یک هواشناس ممکن است به ابرها متفاوت از دید یک هنرمند بنگرد. به این نوع نگاه، _تفکر معماری_ گفته می‌شود. متأسفانه بسیاری از معماران بر این باورند که تفکر معماری صرفاً به معنای «اندیشیدن درباره معماری» است، همان‌گونه که در شکل 2-1 نشان داده شده است.

###### شکل 2-1. تفکر معماری (iStockPhoto)

اما تفکر معماری بسیار فراتر از این است. این به معنای نگاه کردن به مسائل با دید معماری یا از نقطه‌نظر معماری است. چهار جنبه اصلی تفکر شبیه به یک معمار وجود دارد:  
اول، درک تفاوت بین _architecture_ و _design_ و دانستن چگونگی همکاری با تیم‌های توسعه برای به ثمر رساندن معماری.  
دوم، داشتن گستره وسیعی از دانش فنی در کنار حفظ میزان مشخصی از _technical depth_ که به معمار امکان می‌دهد راهکارها و امکاناتی را ببیند که دیگران قادر به دیدن آن نیستند.  
سوم، توانایی درک، تحلیل و متعادل‌سازی _trade-off_‌ها میان راهکارها و فناوری‌های مختلف.  
و در نهایت، درک اهمیت _business drivers_ و چگونگی ترجمه آن‌ها به دغدغه‌های معماری.

در این فصل، این چهار جنبه از تفکر معماری و نگاه به مسائل با دید یک معمار را بررسی خواهیم کرد.

---

## معماری در مقابل طراحی (_Architecture Versus Design_)

تفاوت میان معماری و طراحی اغلب گیج‌کننده است. معماری کجا تمام می‌شود و طراحی از کجا آغاز می‌شود؟ مسئولیت‌های یک معمار در مقایسه با مسئولیت‌های یک توسعه‌دهنده چیست؟ تفکر مانند یک معمار یعنی دانستن تفاوت _architecture_ و _design_ و دیدن اینکه این دو چگونه به شکلی نزدیک با یکدیگر ادغام می‌شوند تا راه‌حل‌هایی برای مشکلات تجاری و فنی ایجاد کنند.

به شکل 2-2 توجه کنید که مسئولیت‌های سنتی یک معمار را در مقایسه با یک توسعه‌دهنده نشان می‌دهد. همان‌گونه که در دیاگرام نشان داده شده است، معمار مسئول کارهایی همچون تحلیل نیازهای تجاری به منظور استخراج و تعریف ویژگی‌های معماری (که به “-ilities” معروف‌اند)، انتخاب _architecture patterns_ و سبک‌های (_styles_) مناسب با حوزه مسئله، و ایجاد _components_ (ساختارهای پایه‌ای سیستم) است. مصنوعات حاصل از این فعالیت‌ها سپس به تیم توسعه تحویل داده می‌شود که مسئول ایجاد _class diagrams_ برای هر _component_، طراحی _user interface screens_ و توسعه و آزمون _source code_ است.

###### شکل 2-2. دیدگاه سنتی معماری در مقابل طراحی

چندین مشکل در مدل سنتی مسئولیت‌ها که در شکل 2-2 نمایش داده شده وجود دارد. در واقع، همین تصویر دقیقاً نشان می‌دهد که چرا معماری به‌ندرت به‌درستی کار می‌کند. به‌طور خاص، فلش یک‌جهته‌ای که از میان موانع فیزیکی و مجازی جداکننده معمار از توسعه‌دهنده عبور می‌کند، منشأ تمام مشکلات مرتبط با معماری است. گاهی تصمیم‌هایی که معمار می‌گیرد هرگز به تیم توسعه منتقل نمی‌شوند و همچنین تصمیم‌هایی که تیم توسعه می‌گیرد و باعث تغییر معماری می‌شوند، به ندرت دوباره به معمار بازگردانده می‌شوند. در این مدل، معمار از تیم توسعه جداست و به همین دلیل معماری به ندرت همان چیزی را ارائه می‌دهد که در ابتدا برای آن طراحی شده بود.

برای اینکه معماری به‌درستی عمل کند، باید هر دو مانع فیزیکی و مجازی که بین معماران و توسعه‌دهندگان وجود دارد برداشته شود تا یک ارتباط دوطرفه قوی بین معماران و تیم‌های توسعه شکل بگیرد. معمار و توسعه‌دهنده باید در یک تیم مجازی واحد قرار داشته باشند تا این همکاری مؤثر واقع شود، همان‌طور که در شکل 2-3 نمایش داده شده است. این مدل نه تنها برقراری ارتباط دوطرفه قوی بین معماری و توسعه را تسهیل می‌کند، بلکه به معمار اجازه می‌دهد نقش _mentoring_ و _coaching_ را برای توسعه‌دهندگان تیم ایفا کند.

###### شکل 2-3. کارآمد کردن معماری از طریق همکاری

برخلاف رویکردهای سنتی _waterfall_ در معماری نرم‌افزار که ایستا و سخت‌گیرانه هستند، معماری سیستم‌های امروزی در هر _iteration_ یا فاز پروژه تغییر و تکامل پیدا می‌کند. همکاری نزدیک بین معمار و تیم توسعه برای موفقیت هر پروژه نرم‌افزاری ضروری است. بنابراین، معماری دقیقاً کجا به پایان می‌رسد و طراحی از کجا آغاز می‌شود؟ پاسخ این است که چنین نقطه پایانی وجود ندارد. این دو بخشی از چرخه حیات یک پروژه نرم‌افزاری هستند و باید همواره با یکدیگر هماهنگ و همگام باقی بمانند تا پروژه موفق شود.

---

## گستره فنی (_Technical Breadth_)

دامنه جزئیات فنی بین توسعه‌دهندگان و معماران متفاوت است. برخلاف یک توسعه‌دهنده که برای انجام وظایف خود باید _technical depth_ قابل‌توجهی داشته باشد، یک _software architect_ برای تفکر معماری و دیدن مسائل از نقطه‌نظر معماری، باید _technical breadth_ زیادی داشته باشد. این موضوع با هرم دانشی که در شکل 2-4 نشان داده شده، به تصویر کشیده شده است. این هرم کل دانش فنی موجود در جهان را بازنمایی می‌کند. در واقع، نوع اطلاعاتی که یک متخصص فناوری باید برای خود ارزش‌گذاری کند، با توجه به مرحله شغلی او تفاوت دارد.

###### شکل 2-4. هرم نمایانگر کل دانش

همان‌گونه که در شکل 2-4 نشان داده شده است، هر فرد می‌تواند کل دانش خود را به سه بخش تقسیم کند: _stuff you know_ (چیزهایی که می‌دانی)، _stuff you know you don’t know_ (چیزهایی که می‌دانی که نمی‌دانی) و _stuff you don’t know you don’t know_ (چیزهایی که نمی‌دانی که نمی‌دانی).

بخش _stuff you know_ شامل فناوری‌ها، _framework_‌ها، زبان‌ها و ابزارهایی است که یک متخصص فناوری به طور روزانه از آن‌ها برای انجام کار خود استفاده می‌کند؛ مثلاً دانستن Java برای یک Java programmer. بخش _stuff you know you don’t know_ شامل چیزهایی است که متخصص فناوری کمی در مورد آن‌ها می‌داند یا اسمشان را شنیده ولی تسلطی بر آن‌ها ندارد. نمونه‌ای مناسب از این سطح دانش، زبان برنامه‌نویسی Clojure است. بیشتر متخصصان شنیده‌اند که Clojure یک زبان برنامه‌نویسی مبتنی بر Lisp است، اما توانایی کدنویسی با آن را ندارند. بخش _stuff you don’t know you don’t know_ بزرگ‌ترین بخش هرم دانش است و شامل همه انواع فناوری‌ها، ابزارها، _framework_‌ها و زبان‌هایی است که می‌توانند بهترین راه‌حل برای یک مشکل باشند اما متخصص حتی از وجودشان آگاه نیست.

تمرکز مسیر شغلی یک توسعه‌دهنده در ابتدای کار، افزایش بخش بالای هرم است تا تجربه و تخصص به دست آورد. این کار در مراحل اولیه مسیر شغلی ایده‌آل است، زیرا توسعه‌دهندگان به دیدگاه گسترده‌تر، آگاهی عملی و تجربه دست‌اول نیاز دارند. گسترش بخش بالایی هرم به‌طور ضمنی باعث گسترش بخش میانی نیز می‌شود، چرا که با مواجهه با فناوری‌ها و مصنوعات مرتبط جدید، دامنه‌ی _stuff you know you don’t know_ افزایش می‌یابد.

در شکل 2-5، گسترش بخش بالایی هرم سودمند است زیرا تخصص ارزشمند است. با این حال، آنچه در بخش بالای هرم قرار دارد، همان چیزی است که باید **حفظ شود**—هیچ چیز در دنیای نرم‌افزار ایستا نیست. اگر یک توسعه‌دهنده در Ruby on Rails متخصص باشد، این تخصص اگر یک یا دو سال آن را کنار بگذارد، دوام نخواهد داشت. دانش قرارگرفته در بخش بالای هرم نیازمند سرمایه‌گذاری زمانی برای حفظ خود است. در نهایت، اندازه بخش بالای هرم هر فرد نشان‌دهنده _technical depth_ اوست.

###### شکل 2-5. توسعه‌دهندگان باید تخصص خود را برای حفظ آن نگهداری کنند

اما وقتی یک توسعه‌دهنده به نقش معمار منتقل می‌شود، ماهیت دانش تغییر می‌کند. بخش بزرگی از ارزش یک معمار در داشتن درک _وسیع_ از فناوری و چگونگی استفاده از آن برای حل یک مشکل مشخص است. برای مثال، برای یک معمار، دانستن اینکه پنج راه‌حل برای یک مشکل وجود دارد، بسیار ارزشمندتر از داشتن تخصص عمیق فقط در یکی از آن‌هاست. مهم‌ترین بخش‌های هرم برای معماران، بخش بالایی و میانی هستند. اینکه بخش میانی تا چه اندازه به بخش پایینی نفوذ کرده، نشان‌دهنده _technical breadth_ یک معمار است، همان‌گونه که در شکل 2-6 نشان داده شده است.

###### شکل 2-6. آنچه کسی می‌داند عمق فنی است و میزان دانسته‌ها گستره فنی

برای یک معمار، _breadth_ مهم‌تر از _depth_ است. چون معمار باید تصمیم‌هایی بگیرد که قابلیت‌ها را با محدودیت‌های فنی تطبیق دهد، داشتن دیدی گسترده از مجموعه متنوعی از راهکارها ارزشمند است. بنابراین، مسیر عاقلانه برای یک معمار این است که بخشی از تخصص به‌سختی به دست‌آمده خود را کنار گذاشته و از این زمان برای گسترش دامنه دانسته‌های خود استفاده کند، همانطور که در شکل 2-7 نشان داده شده است. برخی حوزه‌های تخصصی باقی می‌مانند—احتمالاً آن‌هایی که برای معمار لذت‌بخش‌تر هستند—اما برخی دیگر به‌طور مفید کاهش می‌یابند.

###### شکل 2-7. گسترش دامنه و کاهش عمق فنی در نقش معمار

هرم دانش به ما نشان می‌دهد که نقش _architect_ اساساً چقدر با نقش _developer_ تفاوت دارد. توسعه‌دهندگان تمام عمر کاری خود را صرف تعمیق تخصص می‌کنند، اما ورود به نقش معمار به معنای تغییر این دیدگاه است—تغییری که بسیاری از افراد با آن مشکل دارند. این تغییر، دو اختلال رایج را ایجاد می‌کند: اول، معمار تلاش می‌کند تخصص خود را در حوزه‌های گسترده حفظ کند اما در هیچ‌یک موفق نمی‌شود و خود را خسته می‌کند. دوم، بروز _stale expertise_ یا «تخصص منسوخ» است—حس اشتباه اینکه دانش قدیمی هنوز به‌روز و پیشرفته است. این الگو را اغلب در شرکت‌های بزرگی می‌بینیم که توسعه‌دهندگانی که شرکت را بنیان‌گذاری کرده‌اند به نقش‌های رهبری رسیده‌اند ولی هنوز با معیارهای قدیمی تصمیم‌های فنی می‌گیرند (رجوع کنید به “Frozen Caveman Anti-Pattern”).

معماران باید بر _technical breadth_ تمرکز کنند تا گزینه‌های بیشتری برای انتخاب داشته باشند. توسعه‌دهندگانی که به نقش معمار وارد می‌شوند، ممکن است لازم باشد دیدگاه خود را نسبت به فرایند فراگیری دانش تغییر دهند. ایجاد تعادل بین عمق و گستره دانش چیزی است که هر توسعه‌دهنده باید در طول مسیر شغلی خود مدنظر داشته باشد.

### **الگوی ضدرفتاری Frozen Caveman Anti-Pattern**

یک _anti-pattern_ رفتاری که به‌طور رایج در عمل دیده می‌شود، _Frozen Caveman Anti-Pattern_ است که معمار را توصیف می‌کند که همیشه در هر معماری به نگرانی غیرمنطقی مورد علاقه خود بازمی‌گردد. برای مثال، یکی از همکاران Neal روی سیستمی کار می‌کرد که دارای یک معماری متمرکز بود. با این حال، هر بار که طراحی را به معماران مشتری تحویل می‌دادند، سؤال مکرر آن‌ها این بود: «اگر ایتالیا را از دست بدهیم چه؟»  
چند سال قبل، یک مشکل ارتباطی عجیب باعث شده بود که دفتر مرکزی نتواند با فروشگاه‌های خود در ایتالیا ارتباط برقرار کند و این اختلال مشکلات زیادی ایجاد کرده بود. هرچند احتمال رخداد مجدد این اتفاق بسیار اندک بود، معماران به شکل وسواس‌گونه‌ای روی این ویژگی خاص معماری تمرکز یافته بودند.

به طور کلی، این _anti-pattern_ در معمارانی دیده می‌شود که در گذشته بر اثر یک تصمیم اشتباه یا وقوع یک اتفاق غیرمنتظره آسیب دیده‌اند و در نتیجه در آینده بیش‌ازحد محتاط می‌شوند. البته ارزیابی ریسک اهمیت دارد، اما باید واقع‌بینانه باشد. درک تفاوت بین ریسک فنی واقعی و ریسک فنی تصوری، بخشی از فرایند یادگیری مداوم معماران است. تفکر مانند یک معمار مستلزم غلبه بر چنین ایده‌ها و تجربیات «غارنشین منجمد» است، دیدن سایر راه‌حل‌ها و مطرح کردن پرسش‌های مرتبط‌تر.

---

## **تحلیل _Trade-Off_‌ها (Analyzing Trade-Offs)**

تفکر مانند یک معمار به معنای دیدن _trade-off_ در هر راه‌حل، چه فنی و چه غیرفنی، و تحلیل آن‌ها برای تعیین بهترین گزینه است. به نقل از Mark (یکی از نویسندگان):

> **Architecture is the stuff you can’t Google.**

در معماری، _همه‌چیز_ یک _trade-off_ است؛ به همین دلیل پاسخ مشهور به هر سؤال معماری در جهان این است: «بستگی دارد.» هرچند این پاسخ باعث نارضایتی بسیاری می‌شود، اما حقیقت دارد. شما نمی‌توانید با جستجو در Google بفهمید که در یک پروژه REST بهتر است یا _messaging_، یا اینکه _microservices_ سبک معماری مناسبی هست یا نه، چون واقعاً «بستگی دارد.»  
این موضوع بستگی دارد به **محیط استقرار**، **عوامل تجاری (business drivers)**، **فرهنگ سازمان**، **بودجه**، **زمان‌بندی‌ها**، **مهارت تیم توسعه** و ده‌ها عامل دیگر. محیط، موقعیت و مشکل هر سازمان با دیگری متفاوت است و همین دلیل دشواری معماری است. به نقل از Neal (یکی دیگر از نویسندگان):

> **هیچ پاسخ درست یا غلطی در معماری وجود ندارد—فقط _trade-off_‌ها هستند.**

به عنوان مثال، به سیستم مزایده کالا که در شکل 2-8 نشان داده شده توجه کنید؛ جایی که فردی برای یک کالا پیشنهاد قیمت (_bid_) ثبت می‌کند.

###### شکل 2-8. نمونه یک _trade-off_ در سیستم مزایده—_queues_ یا _topics_؟

سرویس **Bid Producer** یک پیشنهاد قیمت را از پیشنهاددهنده دریافت کرده و سپس این مبلغ را به سرویس‌های **Bid Capture**، **Bid Tracking** و **Bid Analytics** ارسال می‌کند. این کار می‌تواند به دو روش انجام شود:

- استفاده از _queues_ در مدل پیام‌رسانی _point-to-point_
- استفاده از یک _topic_ در مدل پیام‌رسانی _publish-and-subscribe_

کدام‌یک را باید معمار انتخاب کند؟ این پاسخی نیست که بتوان آن را در Google یافت. تفکر معماری نیازمند این است که معمار _trade-off_‌های هر گزینه را تحلیل کرده و بهترین انتخاب را متناسب با موقعیت خاص انجام دهد.

دو روش پیام‌رسانی برای این سیستم مزایده در شکل‌های 2-9 و 2-10 آمده است: شکل 2-9 استفاده از _topic_ را در مدل _publish-and-subscribe_ نشان می‌دهد و شکل 2-10 استفاده از _queues_ را در مدل _point-to-point_ نمایش می‌دهد.

###### شکل 2-9. استفاده از _topic_ برای ارتباط بین سرویس‌ها

###### شکل 2-10. استفاده از _queues_ برای ارتباط بین سرویس‌ها

مزیت واضح (و شاید بدیهی) در شکل 2-9، _extensibility_ معماری است. سرویس **Bid Producer** در این روش فقط به یک اتصال به _topic_ نیاز دارد، درحالی‌که در راهکار _queue_ (شکل 2-10) این سرویس باید به سه _queue_ مجزا متصل شود. اگر قرار باشد سرویس جدیدی به نام **Bid History** برای ارائه تاریخچه‌ی همه پیشنهادهای هر کاربر به سیستم اضافه شود، در مدل _topic_ هیچ تغییری لازم نیست. سرویس جدید می‌تواند تنها با _subscribe_ شدن به _topic_ حاوی اطلاعات _bids_، داده‌ها را دریافت کند.  
اما در روش _queue_، باید یک _queue_ جدید برای **Bid History** ایجاد شود و **Bid Producer** نیز تغییر کند تا یک اتصال جدید به این _queue_ اضافه شود.

به بیان دیگر، استفاده از _queues_ هنگام افزودن قابلیت‌های جدید، تغییرات عمده‌ای در سیستم می‌طلبد، ولی روش _topic_ مستلزم هیچ تغییری در زیرساخت موجود نیست. همچنین، در مدل _topic_، **Bid Producer** مستقل‌تر (decoupled) عمل می‌کند زیرا نمی‌داند این اطلاعات توسط چه سرویس‌هایی و چگونه استفاده می‌شود. اما در روش _queue_، **Bid Producer** دقیقاً می‌داند چه کسی و چگونه از این اطلاعات استفاده می‌کند، و همین باعث افزایش وابستگی (coupling) می‌شود.

با این تحلیل، به نظر می‌رسد مدل _topic_ با رویکرد _publish-and-subscribe_ بهترین انتخاب است. با این حال، به نقل از Rich Hickey، خالق زبان برنامه‌نویسی Clojure:

> **Programmers know the benefits of everything and the trade-offs of nothing. Architects need to understand both.**

تفکر معماری یعنی دیدن مزایای یک راهکار انتخابی، اما همچنین تحلیل معایب یا همان _trade-off_‌های آن.

اگر مثال سیستم مزایده را ادامه دهیم، یک معمار نرم‌افزار باید معایب راهکار _topic_ را هم بررسی کند. اولین نکته این است که در شکل 2-9، در روش _topic_، **هر کسی** می‌تواند به داده‌های پیشنهاد قیمت دسترسی یابد که ممکن است مشکل در _data access_ و امنیت داده‌ها (_data security_) ایجاد کند. اما در مدل _queue_ (شکل 2-10)، داده‌ای که به _queue_ ارسال می‌شود فقط توسط _consumer_ معین قابل دریافت است. اگر یک سرویس مخرب به یک _queue_ گوش دهد، پیام به سرویس مربوطه نخواهد رسید و یک اعلان فوری درباره از دست رفتن داده (و احتمال نقص امنیتی) ثبت می‌شود. به عبارت دیگر، نفوذ به یک _topic_ خیلی راحت‌تر از یک _queue_ است.

علاوه بر مسئله امنیت، راهکار _topic_ در شکل 2-9 تنها از قراردادهای همگن (_homogeneous contracts_) پشتیبانی می‌کند. بدین معنا که تمام سرویس‌هایی که داده مربوط به پیشنهاد قیمت را دریافت می‌کنند، باید یک قرارداد و مجموعه داده یکسان را بپذیرند. در گزینه _queue_ در شکل 2-10، هر _consumer_ می‌تواند قرارداد مختص خود را بر اساس داده‌ای که نیاز دارد داشته باشد. برای مثال، فرض کنید سرویس جدید **Bid History** به قیمت فعلی کالا (_current asking price_) همراه با مبلغ پیشنهاد نیاز دارد، در حالی که هیچ سرویس دیگری به این اطلاعات احتیاج ندارد. در این حالت، در مدل _topic_ باید قرارداد موجود تغییر کند که تمامی سرویس‌های استفاده‌کننده از این داده را تحت تأثیر قرار می‌دهد. اما در مدل _queue_ این قابلیت به صورت یک کانال جدا و در نتیجه یک قرارداد جدا پیاده‌سازی می‌شود که روی سرویس‌های دیگر اثری نخواهد داشت.

عیب دیگر مدل _topic_ که در شکل 2-9 نمایش داده شده، این است که از قابلیت مانیتور کردن تعداد پیام‌ها در _topic_ و در نتیجه _auto-scaling_ پشتیبانی نمی‌کند. اما در گزینه _queue_ در شکل 2-10، هر _queue_ را می‌توان به صورت مجزا مانیتور کرد و _programmatic load balancing_ را برای هر _bidding consumer_ به کار برد، به نحوی که هرکدام بتوانند به‌طور مستقل مقیاس‌پذیری خودکار داشته باشند. توجه داشته باشید که این _trade-off_ وابسته به فناوری است؛ برای مثال، در **AMQP** می‌توان _programmatic load balancing_ و مانیتورینگ را به دلیل جداسازی بین _exchange_ (مکانی که _producer_ به آن پیام می‌فرستد) و _queue_ (مکانی که _consumer_ پیام را دریافت می‌کند) اجرا کرد.

با توجه به این تحلیل _trade-off_‌ها، الان کدام گزینه بهتر است؟ پاسخ همان است: «بستگی دارد!»  
جدول 2-1 این _trade-off_‌ها را خلاصه می‌کند:

- _Architectural extensibility_
- دغدغه‌های _data access_ و _data security_
- _Service decoupling_
- عدم پشتیبانی از _heterogeneous contracts_
- مانیتورینگ و مقیاس‌پذیری برنامه‌ریزی‌شده (_programmatic scalability_)

نکته این است که _همه‌چیز_ در معماری نرم‌افزار یک _trade-off_ دارد — یک مزیت و یک عیب. تفکر مانند یک معمار یعنی تحلیل این _trade-off_‌ها و پرسیدن این سؤال که: «کدام مهم‌تر است؟ _extensibility_ یا امنیت؟» انتخاب میان راهکارهای مختلف همواره وابسته به _business drivers_، محیط و مجموعه زیادی عوامل دیگر خواهد بود.

---

## درک _Business Drivers_ (_Understanding Business Drivers_)

تفکر مانند یک معمار یعنی درک _business drivers_ ضروری برای موفقیت سیستم و ترجمه آن الزامات به ویژگی‌های معماری (_architecture characteristics_) مانند _scalability_، _performance_ و _availability_. انجام این کار دشوار است و نیاز دارد معمار تا حدی با حوزه کسب‌وکار آشنا بوده و رابطه‌ای سالم و تعاملی با ذی‌نفعان کلیدی کسب‌وکار داشته باشد.  
چند فصل بعدی کتاب به این موضوع اختصاص یافته‌اند: در فصل ۴، ویژگی‌های مختلف معماری تعریف می‌شوند؛ در فصل ۵، روش‌های شناسایی و ارزیابی آن‌ها شرح داده می‌شود؛ و در فصل ۶، روش اندازه‌گیری هر یک از این ویژگی‌ها برای اطمینان از برآورده شدن نیازهای تجاری سیستم بیان می‌گردد.

---

## ایجاد تعادل بین معماری و کدنویسی عملی (_Balancing Architecture and Hands-On Coding_)

یکی از چالش‌های دشوار برای یک معمار این است که چگونه بین انجام کدنویسی عملی و کار بر روی معماری نرم‌افزار تعادل ایجاد کند. ما معتقدیم هر معمار باید کدنویسی انجام دهد و بتواند سطحی از _technical depth_ را حفظ کند (رجوع شود به “Technical Breadth”). هرچند این کار ساده به نظر می‌رسد، اما در عمل گاهی به سختی قابل انجام است.

اولین توصیه در رسیدن به این تعادل، اجتناب از تله‌ی _bottleneck trap_ است. این وضعیت زمانی رخ می‌دهد که معمار مالک کدی در _critical path_ یک پروژه (معمولاً کدهای بنیادین _framework_) می‌شود و به گلوگاه پیشرفت تیم تبدیل می‌گردد. دلیل این مشکل این است که معمار یک توسعه‌دهنده تمام‌وقت نیست و باید بین نقش توسعه‌دهنده (نوشتن و تست _source code_) و نقش معمار (ترسیم دیاگرام‌ها، حضور در جلسات، و البته جلسات بیشتر) تعادل برقرار کند.

یکی از روش‌های جلوگیری از این تله به عنوان یک _software architect_ مؤثر این است که کدهای _critical path_ و _framework_ را به سایر اعضای تیم توسعه واگذار کرده و خود بر روی پیاده‌سازی بخشی از قابلیت‌های تجاری (یک سرویس یا یک صفحه) برای یکی تا سه _iteration_ بعد تمرکز کند.  
با این کار سه نتیجه مثبت حاصل می‌شود:

1. معمار ضمن نوشتن کد تولیدی واقعی، از تبدیل شدن به گلوگاه تیم دوری می‌کند.
2. کدهای حساس و بنیادین به تیم توسعه منتقل می‌شوند (جایی که باید باشند) و این انتقال باعث به‌دست آمدن مالکیت و درک بهتر قسمت‌های دشوار سیستم توسط تیم می‌شود.
3. و شاید مهم‌تر از همه، معمار همان کدهای مرتبط با قابلیت‌های تجاری را می‌نویسد که تیم توسعه نیز مشغول انجام آن است، و این موضوع باعث می‌شود که معمار چالش‌ها و مشکلات احتمالی تیم توسعه را در فرآیندها، رویه‌ها و محیط توسعه بهتر درک کند.

اما فرض کنید که معمار نتواند همراه با تیم توسعه کدنویسی کند. در این شرایط، یک معمار نرم‌افزار چگونه می‌تواند همچنان _hands-on_ باقی بماند و سطحی از _technical depth_ خود را حفظ کند؟ چهار راه‌حل اساسی برای انجام این کار وجود دارد که نیاز به «تمرین کدنویسی در خانه» ندارد (اگرچه ما تمرین در خانه را هم توصیه می‌کنیم).

اولین روش، انجام مکرر _proof-of-concepts_ یا **POCs** است. این کار نه تنها نیازمند نوشتن _source code_ توسط معمار است، بلکه به اعتبارسنجی تصمیم‌های معماری با در نظر گرفتن جزئیات پیاده‌سازی کمک می‌کند. برای مثال، اگر معمار بین دو راهکار _caching_ مردد باشد، یکی از روش‌های مؤثر برای تصمیم‌گیری این است که یک نمونه کاری با هر محصول _caching_ پیاده‌سازی و نتایج را مقایسه کند. این کار به معمار امکان می‌دهد جزئیات پیاده‌سازی و میزان تلاش لازم برای ایجاد یک راه‌حل کامل را از نزدیک ببیند. همچنین، امکان مقایسه بهتر ویژگی‌های معماری مانند _scalability_، _performance_ یا تحمل خطای کلی (_fault tolerance_) در راهکارهای مختلف را فراهم می‌کند.

توصیه ما هنگام انجام کارهای _proof-of-concept_ این است که معمار تا حد ممکن کدی در سطح **production-quality** بنویسد. دو دلیل برای این توصیه وجود دارد:

- اول، معمولاً کدهای _proof-of-concept_ که قرار بوده موقتی باشند، به مخزن _source code_ راه پیدا می‌کنند و به عنوان _reference architecture_ یا نمونه راهنمای دیگران استفاده می‌شوند. آخرین چیزی که یک معمار می‌خواهد این است که کد موقتی و بی‌کیفیت او به عنوان نمونه‌ای از کارش در نظر گرفته شود.
- دوم، با نوشتن _proof-of-concept_ با کیفیت تولیدی، معمار تمرین نوشتن کد تمیز و ساختاریافته را انجام می‌دهد، به جای اینکه به طور مداوم عادت‌های بد کدنویسی را تقویت کند.

روشی دیگر برای حفظ _hands-on_ بودن معمار این است که او بخشی از _technical debt stories_ یا _architecture stories_ را بر عهده بگیرد تا تیم توسعه بتواند روی _functional user stories_ حیاتی تمرکز کند. این نوع داستان‌ها معمولاً اولویت پایینی دارند، بنابراین اگر معمار نتواند یک _technical debt_ یا _architecture story_ را در طول یک _iteration_ به پایان برساند، اتفاق مهمی نیفتاده و معمولاً تأثیری بر موفقیت _iteration_ ندارد.

به همین شکل، کار بر روی رفع _bug_ها در طول یک _iteration_ نیز روشی دیگر برای حفظ مهارت کدنویسی عملی در کنار کمک به تیم توسعه است. هرچند این کار چندان جذاب نیست، اما به معمار کمک می‌کند تا نقاط مشکل‌دار و ضعف‌های موجود در _code base_ و حتی معماری را شناسایی کند.

به‌کارگیری _automation_ از طریق ساخت ابزارهای ساده _command-line_ و _analyzers_ برای کمک به تیم توسعه در انجام وظایف روزمره، روش عالی دیگری برای حفظ مهارت‌های کدنویسی عملی در حالی است که بهره‌وری تیم توسعه نیز افزایش می‌یابد. کافی است کارهای تکراری که تیم توسعه بارها انجام می‌دهد شناسایی و فرآیند آن‌ها را خودکار کنید. تیم توسعه از این اتوماسیون قدردان خواهد بود. نمونه‌هایی از این کار عبارت‌اند از:

- _automated source validators_ برای بررسی رعایت _coding standards_ خاصی که در دیگر تست‌های _lint_ بررسی نمی‌شوند،
- _checklists_ خودکار،
- و وظایف تکراری _manual code refactoring_.

_Automation_ همچنین می‌تواند در قالب _architectural analysis_ و _fitness functions_ برای تضمین پویایی و انطباق معماری انجام شود. برای مثال، یک معمار می‌تواند با استفاده از پلتفرم Java و کتابخانه **ArchUnit** کدی بنویسد تا به صورت خودکار _architectural compliance_ را بررسی کند، یا _fitness functions_ سفارشی ایجاد کند تا انطباق معماری را تضمین کرده و همزمان تجربه عملی کدنویسی را کسب کند. ما در فصل ۶ به این تکنیک‌ها خواهیم پرداخت.

آخرین روش برای حفظ _hands-on_ بودن یک معمار، انجام _code reviews_ مکرر است. هرچند معمار در این حالت مستقیماً کدی نمی‌نویسد، اما همچنان با _source code_ درگیر است. علاوه بر این، _code review_ مزایای دیگری نیز دارد: امکان تضمین انطباق با معماری، و همچنین ایجاد فرصت برای ارائه _mentoring_ و _coaching_ به اعضای تیم.